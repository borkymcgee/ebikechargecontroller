#    ebikechargecontroller, Copyright (C) 2025  Juno Presken
#    E-mail: juno.presken+github@protonmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

esphome:
  name: junos-ebike-charger
  friendly_name: Juno's Ebike Charger

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

binary_sensor:
  - platform: gpio
    name: "Knob Button"
    id: knob_button
    icon: "mdi:knob"
    pin:
      number: GPIO35
      mode:
        input: true
    filters:
      - invert:
  - platform: template  #if battery voltage drops lower than 0, theres no battery
    name: "Battery Present"
    id: battery_presence
    icon: "mdi:battery-check"
    lambda: 'return !isnan(id(battery_percentage).state);'
    on_release:
      then:
        - lambda: 'id(setpoint_reached).publish_state(false);'
  - platform: template
    name: "Battery Charging"
    icon: "mdi:battery-charging"
    lambda: "return id(charge_relay).state;"
  - platform: template  #changes to true once the setpoint is reached, triggering the charger to wait for the percentage to drop by charge margin before charging again
    id: setpoint_reached

i2c:
  sda: GPIO21
  scl: GPIO22

font:
  - file: "gfonts://Roboto"
    id: roboto_15
    size: 15

  - file: "gfonts://Material+Symbols+Outlined"
    id: icons_10
    size: 10
    glyphs: ["\U0000ea0b"] # mdi-bolt

  - file: "gfonts://Material+Symbols+Outlined"
    id: icons_20
    size: 20
    glyphs: ["\U0000ebdc"] # mdi-battery-0


sensor:
  - platform: adc
    pin: GPIO34
    id: battery_voltage
    name: "Battery Voltage"
    device_class: "voltage"
    state_class: "measurement"
    unit_of_measurement: "V"
    icon: "mdi:lightning-bolt"
    attenuation: auto
    update_interval: 1s
    filters:
      - calibrate_linear:
          method: exact
          datapoints:
          - 2.033 -> 28
          - 2.130 -> 29.4
          - 2.236 -> 30.8
          - 2.335 -> 32.2
          - 2.441 -> 33.6
          - 2.530 -> 35
          - 2.629 -> 36.4
          - 2.726 -> 37.8
          - 2.824 -> 39.2
          - 2.914 -> 40.45
          - 3.029 -> 42.03
        #analysis shows this is very close to a linear 13.8x scale lol
      - lambda: |-
            if (x < 20) return NAN;
            return x;
      - sliding_window_moving_average:
          window_size: 20
          send_every: 1
      - round_to_multiple_of: 0.1
    on_value:
      then:
        - component.update: battery_percentage
  - platform: rotary_encoder
    id: encoder
    pin_a:
      number: GPIO26
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO32
      mode:
        input: true
        pullup: true
    on_clockwise:
      then:
        - if:
            condition:
              - binary_sensor.is_on: knob_button
            then:
              - number.set: # on clockwise turns, increment odometer by 1
                  id: bike_odometer
                  value: !lambda |-
                    return id(bike_odometer).state + 1;
            else:
              - number.increment:
                  id: charge_setpoint
                  cycle: false
    on_anticlockwise:
      then:
        - if:
            condition:
              - binary_sensor.is_on: knob_button
            then:
              - number.increment: #on counter-clockwise turns, increment odometer by 0.1
                  id: bike_odometer
                  cycle: false
            else:
              - number.decrement:
                  id: charge_setpoint
                  cycle: false
  - platform: template
    name: "Battery Percentage"
    id: battery_percentage
    unit_of_measurement: "%"
    icon: "mdi:percent"
    device_class: "battery"
    state_class: "measurement"
    lambda: |-  #linear percentage calculation from 30v-42v
      return(((id(battery_voltage).state - 30)/12)*100);
    on_value:
      then:
        - lambda: |-
            if(id(battery_presence).state){
              if (id(setpoint_reached).state) {  // if the setpoint has already been reached
                //check if percentage is below charge margin
                if (id(battery_percentage).state <= id(charge_setpoint).state - id(charge_margin).state){
                  // if so, change setpoint_reached to false and turn on the relay to charge back up
                  id(setpoint_reached).publish_state(false);
                  id(charge_relay).turn_on();
                } else {  // if setpoint reached, but still within charge margin
                  // set (really keep, likely) charge relay off
                  id(charge_relay).turn_off();
                  }
              } else {  // if setpoint HASN'T been reached yet
                // check if we have reached the setpoint
                if (id(battery_percentage).state >= id(charge_setpoint).state){
                  //if so, change setpoint_reached to true and turn the relay off
                  id(setpoint_reached).publish_state(true);
                  id(charge_relay).turn_off();
                } else {  //if setpoint really hasn't been reached, turn (really keep) relay on
                  id(charge_relay).turn_on();
                }
              }
            }
  - platform: template
    name: "Battery Percentage at last Unplug"
    id: unplug_percentage



number:
  - platform: template  #manually set upon each time plugging in, intended to transfer the bike's odo into hassio manually
    name: "Bike Odometer"
    id: bike_odometer
    unit_of_measurement: "km"
    icon: "mdi:trending_up"
    restore_value: true
    optimistic: true
    step: 0.1
    min_value: 0
    max_value: 999999
  - platform: template  #amount below setpoint to start charging (for hysteresis)
    name: "Charge Margin"
    id: charge_margin
    unit_of_measurement: "%"
    icon: "mdi:speedometer"
    restore_value: true
    min_value: 1
    max_value: 10
    step: 1
    optimistic: true
  - platform: template  #battery percentage to charge to. controlled from rotary encoder or home assistant
    name: "Battery Charge Setpoint"
    id: charge_setpoint
    unit_of_measurement: "%"
    icon: "mdi:speedometer"
    restore_value: true
    step: 1
    min_value: 25
    max_value: 100
    optimistic: true
    on_value:
      then:
        - lambda: |-
            if(id(battery_presence).state){
              if (id(setpoint_reached).state) {  // if the setpoint has already been reached
                //check if percentage is below charge margin
                if (id(battery_percentage).state <= id(charge_setpoint).state - id(charge_margin).state){
                  // if so, change setpoint_reached to false and turn on the relay to charge back up
                  id(setpoint_reached).publish_state(false);
                  id(charge_relay).turn_on();
                } else {  // if setpoint reached, but still within charge margin
                  // set (really keep, likely) charge relay off
                  id(charge_relay).turn_off();
                  }
              } else {  // if setpoint HASN'T been reached yet
                // check if we have reached the setpoint
                if (id(battery_percentage).state >= id(charge_setpoint).state){
                  //if so, change setpoint_reached to true and turn the relay off
                  id(setpoint_reached).publish_state(true);
                  id(charge_relay).turn_off();
                } else {  //if setpoint really hasn't been reached, turn (really keep) relay on
                  id(charge_relay).turn_on();
                }
              }
            }

display:
  - platform: ssd1306_i2c
    rotation: 180
    model: "SSD1306 64x48"
    address: 0x3D
    lambda: |-
      it.printf(0, 0, id(roboto_15), "V:%.2f", id(battery_voltage).state);
      it.printf(0, 15, id(roboto_15), "%%:%.0f", id(battery_percentage).state);
      if (id(knob_button).state) {
        it.printf(0, 30, id(roboto_15), "km%.1f", id(bike_odometer).state);
      } else {
        it.printf(0, 30, id(roboto_15), "SP:%.0f", id(charge_setpoint).state);
      }
      if (id(charge_relay).state) {
        it.printf(40, 14, id(icons_20), "\U0000ebdc");
        it.printf(45, 21, id(icons_10), "\U0000ea0b");
      }

switch:
  - platform: gpio
    pin:
      number: GPIO25
      inverted: true
    id: charge_relay
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Junos-Ebike-Charger"
    password: !secret hotspot_password

web_server:
  port: 80
  version: 3

captive_portal:

